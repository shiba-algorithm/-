# 코딩의 중요성을 간과하지 말라

프로그래밍 대회에서 좋은 성적을 올리기 위한 비결을 당장 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것이다.

복잡하고 읽기 어려운 코드는 디버깅도 어렵고, 한 번에 정확하게 작성하기도 어렵기 때문이다.

간격하고 효율적인 프로그램을 작성하는 능력은 프로그래밍 대회에서 얻어갈 수 있는 가장 큰 소득 중 하나이다.

------------

# 좋은 코드를 짜기 위한 원칙

### 간결한 코드를 작성하기

프로그래밍 대회에서 코드를 작성할 때의 첫 번째 원칙은 가장 간결한 코드를 작성하는 것이다. 코드가 짧으면 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬어지기 때문이다.

하지만 프로그래밍 대회에서는 경우에 따라 일반적인 경우보다 한발짝 더 나아간 방법들을 사용할 수 있다. 대표적인 예가 전역 변수의 광범위한 사용이다. 프로그래밍 대회에서 작성하는 코드는 구조가 매우 단순하고, 각 변수를 읽고 쓰는 부분이 어디인지가 비교적 명확하기 때문에 전역 변수를 쓰더라도 잃는 것이 그렇게 많지 않다.

이 외에도 '흑마법'중 하나는 C/C++ 매크로를 사용해 간결한 코드를 작성하는 것이다. 이 기법은 반복문처럼 자주 타이핑하게 되는 코드의 일부를 매크로로 표현한다.

ex)

```cpp
bool hasDuplicate(const vector<int>& array) {
	for(int i = 0; i < array.size(); ++i)
		for(int j = 0; j < i; ++j)
			if(array[i] == array[j])
				return true;
	return false;
};
```

매크로를 사용하면 다음과 같이 코드를 바꿀 수 있다.

```cpp
#define FOR(i, n) for(int i = 0; i < (n); ++i)
	
bool hasDuplicate(const vector<int>& array) {
	FOR(i, array.size())
		FOR(j, i)
			if(array[i] == array[j])
				return true;
	return false;
}
```

이런 코드를 작성하는 것은 범죄라고 심각하게 주장할 수도 있지만 이런 코드를 이용하면 다음과 같은 실수는 피할 수 있다.
```cpp
for(int i = 0; i < array.size(); ++i)
	for(int j = 0; j < i; ++i)    // ++j 여야한다.
```

물론 이런 실수를 피해 가는 올바른 방법은 배열의 인덱스를 반복문으로 순회하는 대신 C++11의 구간 기반 for문을 사용하는 것이다.

### 적극적으로 코드 재사용하기

간격한 코드를 작성하기 위한 가장 직접적인 방법은 코드를 모듈화하는 것이다. 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것이다.

같은 코드가 세 번 이상 등장한다면 항상 해당 코드를 함수로 분리해 재사용한다는 기본 원칙을 만들면 좋다.

### 표준 라이브러리 공부하기

간결한 코드를 작성하기 위한 또 다른 중요한 원칙은 표준 라이브러리를 사용하는 것이다.

학교에서 자료 구조 수업을 듣고 나서 처음으로 프로그래밍 대회에 참가하는 학생들이 가장 자주 저지르는 실수는 큐나 스택과 같은 자료구조, 혹은 정렬 등의 기초적 알고리즘을 직접 작성한다는 것이다.

프로그래밍 대회에서 모든 코드를 직접 작성하는 것은 대표적인 시간 낭비의 하나이다.

언어의 문자열, 동적 배열, 스택, 큐, 리스트, 사전등의 자료 구조, 정렬 등의 표준적인 알고리즘 구현 사용법을 반드시 잘 알아 두는게 좋다.

### 항상 같은 형태로 프로그램을 작성하기

자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있다.

그래야 도구가 아니라 문제에 집중할 수 있기 때문이다.

### 일관적이고 명료한 명명법 사용하기

```cpp
int a[30][30], i, j, p[100], l = 0, l = -1;
```
위와 같은 코드는 완전히 낙제감이다.

모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익혀야 한다.

ex) 한 개의 점과 원이 주어졌을 때 점이 원 안에 포함되는지 여부를 반환하는 함수
```cpp
bool judge(int y, int x, int cy, int cx, int cr);
```
위와 같은 함수는 언제 참이 반환되는지 명료하지 않다.

같은 코드지만 함수 이름만 바꾸면 훨신 명료해진다.
```cpp
bool isInsdieCircle(int y, int x, int cy, int cx, int cr);
```

### 모든 자료를 정규화해서 저장하기

같은 자료를 두 가지 형태로 저장하지 않는 것이다.

같은 각도를 -30도, 330도나 690도라고 쓸 수 있다. 이런 각도를 표현하는 방법을 한 가지로 정의해 두지 않으면 각도를 다루는 함수들을 작성하기 아주 힘들어진다.

또한 시간을 표현할 경우 이것이 어떤 시간대로 저장되어있는지, 그리고 당시에 일광 절약 시간을 사용했는지 등이 서로 섞이기 일쑤이다. 가장 좋은 방법은 UTC를 표시한 시간과 시간대의 조합으로 시간을 저장하는 것이다.

문자열을 외부에서 읽을때 또한 읽어들이자마자 가능한 한 UTF-8 인코딩 변환해야만 편해진다.

정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어져야 한다. 이상적으로는 자료를 표현하는 클래스의 새성장에서 정규화를 수행하거나, 외부에서 자료를 입력받자마자 정규화를 수행하는 것이 좋다.

### 코드와 데이터를 분리하기

코드의 논리와 상관 없는 데이터는 가능한 한 분리하는 것이 좋다.

예를 들어 날짜를 출력할 때 월을 숫자가 아닌 영문 이름으로 출력해야 할 시 각 월의 영어 이름을 배열로 만들 수 있다.

```cpp
const string monthName[] = {"January", "Februrary" ...};
```

이런 방식은 항상 코드의 양을 줄여서 실수를 하지 않게 도와준다.

------------

# 자주 하는 실수

### 산술 오버플로

계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로다.

### 배열 범위 밖 원소에 접근

```cpp
int array[10], t;
```

이때 변수 array와 t가 메모리 상에 연속해서 위치하게 되엇다고 가정하자. 이때 실수로 array[10] 위치에 값을 대입하면 엉뚱하게도 t에 있던 값이 덮어씌워진다. 이 접근은 어떤 런타임 에러도 내지 않으며, 매우 찾기 어려운 버그가 된다.

### 일관되지 않은 범위 표현 방식 사용하기
[2, 3, 4, ..., 12]를 표현한다고 할때
2 <= i <= 12 (닫힌 구간)
1 < i < 13 (열린 구간)

과 같은 표현 방법이 있다.

- 대부분의 프로그래밍 언어에서 n개의 원소를 갖는 배열 a의 첫 번째 원소는 a[0]이고, 마지막 원소는 a[n-1]이다. 따라서 a의 인덱스 i의 범위는 0 <= i < n이다. (반 열린 구간)
- C++ STL에서는 반복자로 범위를 표현할 때 첫 원소를 가리키는 반복자의 마지막 원소 다음 위치를 가리키는 반복자를 사용한다. 예를 들어 STL 자료구조에서 모든 원소를 갖는 범위는 begin(), end()로 표현하는데, begin()은 첫 번째 원소를 가리키지만 end()는 마지막 원소가 아니라 마지막 원소 다음에 있는 가상의 원소를 가리킨다.

이러한 선택에는 분명한 장점이 있다.

- 첫 번째 값과 마지막 같이 같은 구간을 이용하면 텅 빈 구간을 쉽게 표현할 수 있다. [2,2)로 표현된 반 열린 구같은 2 <= i < 2인 모든 i를 표함하므로 공집합이 된다.
- 두 구간이 연속해 잇는지 쉽게 알 수 잇다. [a, b)와 [c, d)가 연속해 잇는지를 보려면 b=c 혹은 a=d인지만 확인하면 된다.
- 구간의 크기를 쉽게 알 수 있다. [a, b)로 표현된 구간에 포함된 자연수의 수는 b-a가 된다.

하지만 이런 선택이 자연어에서 사용하는 범위와 다르다는 이유 때문에 문제가 생기는 경우가 종종 있다.

배열 A[]의 부분 구간의 평균으 ㄹ구하는 함수 average(A[], i, j)를 만든다고 할때, 첫 n개 수의 평균을 어떻게 구해야 할까?

- 반 열린 구간이면 average(A, 0, n)
- 닫힌 구간이면 average(A, 0, n-1) 

만약 함수 내에서 사용하는 표현 방법과 함수 밖에서 사용하는 표현 방법이 서로 다르다면 혼란이 올 수 있으므로 한 가지 방법으로만 범위를 표현할 필요가 있다.

물론 프로그래밍 언어가 지원하는 범위 표현 방식을 따르는 것이 가장 효율적이다.

### off-by-one 오류

이 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 모두 가리킨다.

ex) 길이가 100m인 담장에 10m 간격으로 울타리 기둥을 세운다고 할시 기둥이 몇 개 필요할까?

정답은 10개가 아니라 11개다.

ex) 정수 배열 A[]가 주어질 때 A[i]부터 A[j]까지의 평균을 구한다고 할때 합을 얼마로 나눠야 할까?

j-i가 아니라 j-i+1로 나누어야 한다.

Off-by-one 오류는 반복문에서 <, > 연산자와 <=, >= 연산자를 혼동하여 원소를 하나 더 적게, 혹은 많이 순회하는 경우나 반 열린 구간과 닫힌 구간을 서로 혼용해서 쓴 경우 흔하게 발생한다.

이런 오류를 방지할 수 있는 좋은 방법으 ㄴ최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 것이다.

### 컴파일러가 잡아주지 못하는 상수 오타

흔히 실수하는 경우로 다음과 같은 것들이 있다.

- 코드와 데이터를 분리하기 위해 데이터를 별도의 상수 배열에 저장하는 것은 좋은 버릇이다. 그러나 여기에 오타가 ㅂ라생하면 멀쩡한 코드만 한참 디버깅할 수도 잇따. 배열ㅇ르 보면서 틀린 점을 찾기 못한다면 이런 버그에 직면할 가능성이 충분하다.
- 출력한 문자열 상수를 잘못 쓰는 것도 종종 있는 실수다. "weird" 혹은 "not weird"를 출력해야 했는데, 프로그램은 잘 짜 놓고 마지막에 "wierd" 라고 출력해서 틀릴 수도 있다.
- 64비트 정수형에 들어갈 상수를 쓰면서 해당 상수가 64비트라고 지정하지 않는 실수 또한 종종 볼 수 있다. C++ 경우에 정수형 상수 뒤에 LL을 붙이지 않으면 해당 상수는 32비트로 가정되므로, 자료ㅗ형이 정확하다고 해도 오버플로가 발생할 수 있다.

### 스택 오버 플로

프로그램의 실행 중 콜 스택(call stack)이 오버플로해서 프로그램이 강제종료 되는 것 또한 흔히 하는 실수다. 스택 오버 플로는 대개 재귀 호출의 깊이가 너무 깊어져서 오는데, 프로그래밍 대회를 공부하면서 재귀 호출을 사용할 일이 굉장히 많기 때문에 이런 점은 늘 유의하는 것이 좋다.

C++의 경우에는 지역 변수로 선언한 배열이나 클래스 인스턴스가 기본적으로 스택 메모리를 사용하기 때문에 특히나 스택 오버플로를 조심해야 한다.

때문에 자동으로 힙에 메모리를 할당하는 STL 컨테이너를 사용하거나 전역 변수를 사용하곤 한다.

### 다차원 배열 인덱스 순서 바꿔 쓰기

프로그래밍 대회에서는 심심찮게 4, 5차원 이상의 고차원 배열을 쓰게 된다. 이 배열을 이곳저곳에서 접근하다 보면 한군데쯤에서 인덱스의 순서를 헷갈려서 잘못 쓰는 일이 흔히 있다.

동적 계획법을 위한 메모이제이션 패턴을 사용할 때 이런 일이 잦은데, 이런 경우에는 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다.

### 최소, 최대 예외 잘못 다루기

예외란 말 그대로 예상한 입력의 규칙에 들어맞지 않는 모든 입력이다. 따라서 '예외를 제대로 처리하지 못한 경우'라는 말은 너무 모호해서 일반적인 실수라고 하기 힘들다. 그러나 가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들은 생각 외로 많으므로, 코ㅡ들 짜 ㄹ때 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작할지를 생각해 보면 오류를 잡을 수 잇는 경우가 꽤 있다.

ex) 자연수를 입력받아 소수(prime number)인지를 판정하는 함수를 예로 들어보자.

```cpp
bool isPrime(int n) {
	if(n % 2 == 0) return false;    // 짝수는 소수가 아님
	for(int i = 2; i < n; ++i) 
		if(n % i == 0)
			return false;    // 2 이상, n 미만의 약수가 있으면 소수가 아님
	return true;    // 통과하면 소수
}
```

가장 먼저 보이는 오류는 모든 짝수를 소수가 아니라고 판단하는 거다. 2는 짝수이지만 소수이다. 2를 별도로 처리해야 한다.
```cpp
bool isPrime(int n) {
	if(n == 2) return true;    // 2는 소수다.
	if(n % 2 == 0) return false;    // 짝수는 소수가 아님
	for(int i = 2; i < n; ++i) 
		if(n % i == 0)
			return false;    // 2 이상, n 미만의 약수가 있으면 소수가 아님
	return true;    // 통과하면 소수
}
```

소수인 가장 작은 입력에 대해 확인했으니, 소수가 아닌 가장 작은 입력도 생각해 봐야한다. 소수가 아닌 가장 작은 자연수는 1이다. 1이 입력될 경우 if문을 모두 통과하고, for문도 실행되지 않고 건너뛰어 true를 반환한다.

이런 예외는 꼼꼼히 처리하기 쉽지 않다는 것을 알 수 있다.

### 연산자 우선순위 잘못 쓰기

사친연산의 우선순위는 잘 알고 있기 때문에 혼동하는 일이 적지만, 시프트 연산자나 비트 단위 연산자들의 우선순위는 종종 헷갈린다.

```cpp
if(b & 1 == 0)
```

위 if문은 얼핏 보면 b의 최하 비트가 0일 때 참인 것처럼 보인다. 그러나 비트단위 AND 연산자인 &의 우선순위는 비교 연산자인 ==보다도 낮기 때문에, 위 if문은 아래와 같이 해석된다.

```cpp
if(b & (1 == 0))
```

결과적으로 조건문은 항상 거짓이 된다.

따라서 연산자의 우선순위들을 잘 기억해 두거나, 헷갈릴 경우에는 괄호로 적절히 감싸는 것을 잊지 말아야 한다.

### 너무 느린 입출력 방식 선택

C++ 에서는 gets()를 이용해 모든 입력을 문자열 하나로 읽어들인 뒤 파싱할 수도 있고, cin등의 고수준 입력 방식을 사용할 수도 있다.

대개의 경우 고수준 입출력 방식을 이용하면 코드가 간단해지지만, 이에 따른 속도 저하 또한 클 수 있다.

따라서 입출력의 양이 많다면 어떤 입출력 방식을 선택하는지가 프로그램의 정답 여부를 충분히 바꿔놓을 만한 요소가 된다.

------------