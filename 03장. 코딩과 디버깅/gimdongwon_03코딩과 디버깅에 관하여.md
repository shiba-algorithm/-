# 코딩과 디버깅에 관하여

## 3.1 도입: 코딩의 중요성을 간과하지말라

프로그래밍 대회에서 어떤 성적을 올리느냐에 가장 직접적으로 결정하는 요인은 알고리즘이나 자료구조에 대한 지식을 제일 먼저 떠올리지만 어떤 의미에서는 코딩 과정은 어떤 문제를 풀 때나 필요하기 때문에 가장 중요하다고 볼 수 있다.

많은 사람들이 대회에서는 알고리즘에 끼워맞춘 스파게티 코드를 짜낸다고 오해한다. 하지만 좋은 성적을 올리기 위한 비결은 당장 빨리 코드를 작성하기 보다 읽기 쉬운 코드를 작성하는 것이다. 복잡하고 읽기 어려운 코드는 디버깅도 어렵고, 한번에 정확하게 작성하기도 어렵기 때문이다. 실제로 프로그래밍 대회 상위 입상자들의 코드에서 시간에 쫓겨 작성한 흔적을 찾기란 어렵다. 많은 대회 참가자들은 반복적인 연습을 통해 자신의 코드 스타일을 간결하고 일관되게 다듬으려고 노력한다.

`간결하고 효율적인 프로그램을 작성하는 능력은 대회에서 얻어갈 수 있는 가장 큰 소득 중 하나다.`

## 3.2 좋은 코드를 짜기 위한 원칙

대회에서 작성하는 코드나 실무에서 작성하는 코드나 좋은 코드의 조건은 크게 다르지 않다. 이 절에서는 대회에서 중요하게 적용되는 원칙들과 예외들을 간략하게 정리한다.

### 간결한 코드를 작성하기

프로그래밍 대회에서 코드를 작성할 때 `첫 번째 원칙은 가장 간결한 코드를 작성하라는 것이다` 코드가 잛으면 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워지기 때문이다. 하지만 프로그래밍 대회에서는 경우에 따라 일반적인 경우보다 더 나아간 방법들을 사용할 수 있다. 일반적인 프로그램에서는 권장하지 않지만 작성하는 프로그램이 짧고 그 용도가 제한되어 있는 프고그래밍 대회의 특성상 잘 가려 사용하면 유용하다.

`그 대표적인 예가 전역 변수의 광범위한 사용이다`

이 외에도 대회에서만 사용하는 흑마법중 하나는 C/C++ 매크로를 사용해 간결한 코드를 작성하는 것이다. 이 기법은 반복문처럼 우리가 자주 타이핑하게 되는 코드의 이룹를 C++매크로로 표현한다. 다음은 정렬되지 않은 정수 배열에 중복 원소가 존재하는지 확인하는 함수다.

```C++
bool hasDuplicate(const vector<int>&array){
  for(int i = 0; i < array.size(); ++i)
   for(int j = 0; j < i; ++j)
     if(array[i]== array[j])
  return true;
}
```

매크로를 사용하면 다음과 같이 바꿀수 있다.

```C++
#define FOR(i,n) for(int i = 0; i < (n); ++i)
  bool hasDuplicate(const vector<int>& array){
  FOR(i,array.size())
    FOR(j,i)
      if(array[i]==array[j])
        return true;
    return false;
  }
```

이런 코드가 범죄라는데.. 나는 잘 모르겠다. 이런 코드를 이용하면 다음과 같은 실수를 피할 수 있다.

```c++
for(int i = 0; i < array.size(); ++i)
  for(int j = 0; j < i; ++i) // ++j 이여야 함
```

물론 이런 실수를 피해가는 올바른 방법은 인덱스를 반복문으로 순회하는 대신 자바나 C#처럼 foreach 구문을 사용하는 것이다. 그러나 C++에는 foreach 구문도 없고, 매크로 덕에 코드가 훨씬 짧아지기 때문에 이런 방법을 사용하는 사람들이 많이 있으며, 가끔 사용하면 아주 유용하다.

### 적극적으로 코드 재사용하기

간결한 코들르 작성하기 위한 가장 직접적인 방법은 코드를 모듈화 하는 것이다.

`같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것이다.` 같은 코드가 세번이상 등장한다면 해당 코드를 함수로 분리해 재사용한다는 기본 원칙을 만드는 것이 좋다. 물론 대회에서는 코드를 개선할 여유가 없지만 더 알기 쉽게 고치는데 주저해서는 안된다. 당장은 차이점이 없어도 스스로 그와 같은 코드에 익숙해지기 때문이다. 간결한 코드에 익숙한 사람은 다음에 비슷한 코드를 짤 때 처음부터 좀 더 간결하게 코딩할 것이기 때문이다. 이 효과는 디버깅 할 때 엄청난 시간의 차이를 가져다 준다.

### 표준 라이브러리 공부하기

간결한 코드를 적성하기 위한 또 다른 중요한 원칙은 표준 라이브러리를 사용하는 것이다. 많은 학생들이 기초적 알고리즘을 직접 작성하는 시간 낭비를 한다. 표준 라이브러리는 셀 수 없을 정도로 많이 사용되고 검증되었으며 메모리 관리나 정당성 증명에 신경 쓸 필요없이 편하게 사용하면 된다. 팀원이 이해하기도 쉽기 때문에 필수적으로 사용한다. 그렇다고 해서 언어의 문자열, 동적 배열, 스택, 큐, 리스트, 사전 등의 자료구조 등 표준적인 알고리즘 구현 사용법을 알고 있어야 한다.

### 항상 같은 형태로 프로그램 작성하기

대회에 참가하다 보면 여러 종류의 코드를 반복적으로 짜게 된다. 이분법, 그래프의 너비 우선 탐색 등의 유명한 알고리즘부터, 2 차원 평면의 점을 표현하는 자료구조 등이 좋은 예이다. 이들은 다른 문제를 해결하는 도구로 흔히 이용되기 때문에 매우 자주 작성하게 된다. 이들은 다른 문제를 해결하는 도구로 흔히 이용되기 때문에 매우 자주 작성하게 된다. 그래ㅓㅅ 같은 코드를 다양한 방식으로 짜보는데 while 문을 do-while 문을 사용해보기도 하고 2 차원 배열의 크기를 세로크기, 가로크기 순으로 전달하다가 가로크기, 세로크기 순으로 전달하기도 한다.

처음에는 자신이 가장 알아보기 슁누 코드를 작성하는데 도움이 되어서 권장할 만 하지만 시간이 지남에 따라 이것은 실수의 원인이 된다.

같은 코드를 좀 더 개선하는데 고민할 필요는 꾸준히 있지만 자주 작성하는 알고리즘이나 코드는 한번 검증하고 이것만을 꾸준히 사용할 필요가 있다.

### 일관적이고 명료한 명명법 사용하기

프로그래밍 대회에 제출된 소스 코드들을 보면 다음과 같은 선언문들을 흔하게 볼수 있다.

```C++
int a[30][30], i, j, p[100], k=0, l=-1
```

이런 코드는 완전히 낙제감이다.

모호하지 않는 변수명과 함수명을 사용하는 버릇을 익히고 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익혀야 한다. 모호한 명명법은 가끔 잡아내기 힘든 오류을 만든다. 작가는 이런 실수를 했다고 한다.

```c++
bool judge(int y, int x, int cy, int cx, int cr);
```

이 코드에서는 두개의 2 차원 좌표와 또 다른 값이 입력으로 주어지고 좌표 순서는 y,x 이다라는 점을 알수 있다. 때문에 언제 참을 리턴하는지 알 수가 없다. 코딩할 때는 점이 원 밖에 있을 때 참을 반환한다고 생각했지만 사용할 때는 안에 있을 때로 착각했다고 한다. 같은 코드지만 함수 이름만 바꾸어도 훨씬 명료해진다.

```c++
bool isInsideCircle(int y, int x, int cy, int cx, int cr);
```

### 모든 자료를 정규화해서 저장하기

> 처음 알았따.

좋은 코드의 또 다른 원칙으로 같은 자료를 두 가지 형태로 저장하지 않는 것이 있다. 예를들어 유리수를 표현하는 class Fraction 을 작성한다고 하면 입력받는 유리수는 항상 약분해 기약 분수로 표현하는 것이 좋다. 그렇지 않으면 9/6 과 3/2 을 표현하는 변수가 따로 존재하게 된다. 이런식으로 같은 자료가 두개 이상의 표현을 가지게 되면 미묘한 버그들을 만들기 쉽다. 각각의 문자열 표현이 달라지고, 해시 값이 달라지는 등의 문제가 있기 때문이다.

![consoleTestImage](../image/Fraction.PNG)

> 위의 그림에서는 오류가 없지만 해시값에서나 문자열 표현이 달라질 순 있겠다.

이런 일들은 실무에서도 흔하게 겪게 되는데 가장 좋은 방법은 항상 협정 세계시(UTC)로 표시한 시간과 시간대의 조합으로 시간을 저장하는 것이다. 문자열을 다루는 프로그램에서 문자열들의 인코딩이 이것 저것 섞여있는 것도 UTF-16, UTF-8 으로 인코딩해야 문자열다루기가 편하다. 정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어쟈한다. 이상적으로 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나, 외부에서 자료를 입력받자마자 정규화를 수행하는 것이 좋다.

### 코드와 데이터 분리하기

날짜를 다루는 프로그램을 작성하는데, 날짜를 출력할 때 월을 숫자가 아니라 영문이름으로 출력해야 한다고 하면 초짜들은 열두줄짜리 함수를 짤것이다. (내가 실제로 이렇게 짬;)

```C++
string getMonthName(int month){
  if(month == 1) return "January";
  if(month == 2) return "February";
  ...
  return "December"
}
```

경험이 생기고 상식이 쌓이고 나면 이런 코드는 피한다. 테이블을 만들수 있겠다.

```C++
const string monthName[] = { "January", "Febuary", ... , "December"};
```

이런 방식은 항상 코드의 양을 줄여서 실수를 하지 않게 도와준다. 같은 프로그램에서 각 달에 포함된 날의 수를 사용하고 싶다면 다음과 같은 정수 배열을 선언하면된다.

```C++
int daysIn[12] = {31,28,31,31,31,...,31}
```

이 기법의 또 다른 좋은 예로 체스 같은 보드 게임이 있다. 체스판에서 말들의 움직임을 다루는 문제를 푸 경우 각 말이 움직일 수 있는 위치를 프로그램으로 작성하는 대신 움직일 수 있는 상대 좌표를 배열에 저장해 두면 좋다.

```C++
  const int knightDx[8] = {2 ,2 ,-2 ,-2 ,1 ,1 ,-1 ,-1};
  const int knightDy[8] = {1, -1, 1, -1, 2, 2, 2, -2};
```

## 3.3 자주 하는 실수

`같은 실수를 반복하기보다는 실수에서 배우는 것이 좋고 그보다 더 좋은 것은 남의 실수로부터 배워 유사한 실수를 저지르지 않는 것이다.` 지금부터 흔히 저지르는 실수를 살펴보자

### 산술 오버플로

대회에서 가장 많이 등장하는 실수는 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로이다. 뒤에서 별도로 다뤄보자

### 배열 범위 밖 원소에 접근

배열 범위 밖의 원소에 접근하는 오류이다. C / C++ 는 배열의 원소에 접근할 때 해당 인덱스가 배열 범위 안에 있는지를 별도로 확인해 주지 않는다. 이 특성은 속도가 중요한 프로그램을 짤 때는 좋지만, 덕분에 배열 범위를 벗어난 위치의 값에 적근하는 버그는 아주 찾기 힘들다. 그나마 이 과정에서 런타임 스택등을 건드려서 배열 범위 밖에 접근했다는 사실을 깨달을 수도 있기 떄문에 오류도 나지 않으면서 틀린 답만 내놓는 경우도 있다.

> forEach 가 인덱스값 떄문에 사용하는 거엿군..

```C++
int array[10], t;
```

이때 변수 array 와 t 가 메모리 상에 연속해서 위치하게 되었다고 한다. 이때 실수로 array[10]위치에 값을 대입하면 어떻게 될까? t 에 있던 값이 덧씌어진다. 매우 힘든 버그다.

이런 실수를 예방하는 가장 좋은 방법은 당연하게도 배열 크기를 정할 떄 계산을 신중히 하는 것이다. 하지만 다른 경우에도 이런 버그가 생길 수 있는데 그중 흔한 것은 0 을 시작으로 하는 범위와 1 을 시작으로 하는 범위를 혼동하는 것이다.

> 컴터는 숫자가 0 부터 시작

### 일관되지 않은 범위 표현 방식 사용하기

배열의 잘못된 위치를 참조하는 오류가 발생하는 큰 원인 중 하나로, 프로그램 내에서 여러가지의 범위 표현 방식을 섞어 쓰는 경우가 있다.

열린구간과 닫힌구간은 서로 장 단점이 있다. `닫힌 구간의 문제는 공집합을 우아하게 표현할 수 있는 방법이 없다. 정 공집합을 표현하고 싶으면 a>b 인 범위 [a,b]를 쓰는 수밖에 없는데 영 직관적이지 않다. 반면 열린 구간의 경우에는 배열의 첫 번째 원소부터 시작하는 범위를 표현하고 싶을 경우 첫 번째 원소 이전에 존재하는 가상의 원소를 사용해야 한다는 문제가 있다. 많은 프로그래밍 언어에서는 배열 인덱스가 0 에서 시작하기 때문에 첫 원소에서 시작하는 열린구간을 표기하기 위해서는 음수를 써여해서 부자연스럽다. 그래서 대부분의 PL 에서는 이 둘 사이의 절충안인 반 열린 구간을 사용한다.` 첫 번째 값은 집합안에 포함하고, 다른 하나는 집합 안에 포함하지 않는다. 예르르들어 [lo, hi1)는 lo, lo+1, ..., hi-2, hi-1 을 포함한다.

- 대부분의 프로그래밍 언어에서 n 개의 원소를 갖는 배열 a 의 첫 번째 원소는 a[0]이고, 마지막 원소는 a[n-1]이다. 따라서 a 의 인덱스 i 의 범위는 `0<=i<n` 이다
- C++ STL 에서는 반복자로 범위를 표현할 때 첫 원소를 가리키는 반복자와 마지막 원소 다음 위치를 가리키는 반복자를 사용한다. 예를 들어 STL 자료구조에서 모든 원소를 갖는 범위는 begin(), end()로 표현하는데, begin()은 첫 번째 원소를 가리키지만 end()는 마지막 원소가 아니라 마지막 원소 다음에 있는 가상의 원소를 가리킨다.
- 자바의 SortedSet 인터페이스는 범위를 fromElement 와 toElement 로 전달받는데, fromElement 는 범위에 포함되지만 toElemnet 는 포함되지 않는다.
- 파이썬에서는 배열의 일부를 a[4:8]과 같은 문법으로 잘라낼 수 있는데, 이렇게 잘라내면 a[4]부터 a[7]까지를 포함하는 부분 배열을 얻을 수 있다.

이러한 선택에는 분명한 장점잉 있다.

- 첫 번째 값과 마지막 값이 같은 구간을 이용하면 텅 빈 구간을 쉽게 표현할 수 있다. [2,2)로 표현된 반 열린 구간은 2<=i<2 인 모든 i 를 포함하므로 공집합이 된다.
- 두 구간이 연속해 있는지를 쉽게 알 수 있다. 두 구간 [a,b), [c,d)가 연속해 있는지를 보려면 b=c 혹은 a=d 만 확인하면 된다.
- 구간의 크기를 쉽게 알 수 있다. [a,b)로 표현된 구간에 포함된 자연수의 수는 b-a 가 된다.

하지만 이런 선택이 자연어에서 사용하는 범위와 다르다는 이유 때문에 문제가 생긴다. 배열 A[]의 부분 구간의 평균을 구하는 함수 average(A[], i, j)를 만든다고 해보면 첫 n 개 수의 평균을 어떻게 구해야 될까 average()가 반 열린 구간을 입력받는다면 average(a, 0, n)을 호출해햐 한다. 만약 함수 내에서 사용하는 표현 방법과 함수 밖에서 사용하는 표현이 다르다면 혼란을 야기할 것이다.

`이런 문제를 피하기 위해서 프로그램 내에서 한가지 방법으로만 범위를 표현해야한다.`

### Off-by-one 오류

이 오류는 계산의 큰 줄기느 ㄴ맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 모두 가리킨다. 예를 들어 길이가 100 미터인 담장에 10 미터 간격으로 울타리 기둥을 세웠을 때 10 개 일까 11 개 일까? 정수 배열 A[]가 주어질 때 A[i]부터 A[j]까지의 평균을 구한다고 해보자. 합을 얼마로 나눠야 할까? j-i 가 아니라 j-i+1 로 나누어야 한다.

이 Off-by-one 오류는 반복문에서 비교 연산자를 혼동하여 원소를 하나 더 적게 혹은 많이 순회하는 경우나 반열린 구간, 닫힌구간을 혼동해 흔하게 발생한다. 이런 오류를 방지하는 좋은 방법은 최소 입력이 주어졌을 때 이 코드가 어덯게 동작할지를 되새겨 보면서 프로그램을 짜는 것이다. 담장의 길이가 0 미터라도 기둥은 하나 박아야 하고, A[1]부터 A[1]까지의 평균을 구할 땐 0 이 아니라 1 로 나눠야 한다.

### 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명에서 낸 오타는 컴파일러가 잡아주기 때문에 걱정하지 않지만 각종 상수를 잘못 입력하는 경우가 있습니다.

- 3.2 절에서 설명한 바와 같이 코드와 데이터를 분리하기 위해 데이터를 별도의 상수 배열에 저장하는 것은 좋은 버릇입니다. 그러나 여기에 오타가 발생하면 멀쩡한 코드만 한참 디버깅할 수도 있다. 실제로 해당 절에서 예로 든 데이터 배열들의 경우 모두 한 군데씩 잘못되어 있다. 배열을 보고서 틀린 점을 못 찾았다면 이 버그일 확률이 크다.
- 출력할 문자열 상수를 잘못 쓰는 것도 종종 있는 실수이다.
- 계산해야할 값이 큰 경우 0 의 개수를 틀리게 쓰거나 하는 실수도 잦다.
- 64 비트 정수형에 들어갈 상수를 쓰면서 해당 상수가 64 비트라고 지정하지 않는 실수 또한 종종 볼 수 있다. C++의 경우 정수형 상수 뒤에 LL 을 붙이지 않으면 해당 상수는 32 비트로 가정되므로, 자료형이 정확하다고 해도 오버플로가 발생할 수 있다. 자신이 사용하는 언어에서 상수의 타ㅣㅇㅂ을 어떻게 지정하는지, 지정하지 않는 경우 어느 형태로 강제되는지에 대해 미리 알아 두는 것이 좋다.

### 스택 오버플로

프로글매의 실행 중 콜 스택이 오버플로해서 프로그램이 강제 종료 되는 것 도한 흔히 하는 실수이다. `스택 오버플로는 대개 재귀 호출의 깊이가 너무 깊어져서 오는데, 대회에서 재귀를 많이 사용하므로 늘 유의해야 한다.`
스택 최대 크기는 컴파일이나 실행시에 설정할 수 있고 기본 값이 언어나 아키텍처 등에 따라 매우 다르기 때문에 대회에서 사용하는 환경의 스택 허용량에 대해 알아 둘 필요가 있다.

C++의 경우에는 지역 변수로 선언한 배열이나 클래스 인스턴스가 기본적으로 스택 메모리를 사용하기 때문에 특히나 스택 오버플로를 조심해야한다. 배열 등의 큰 지역 변수를 스택에 잡으면 재귀 호출이 몇번 없어도 곧장 스택오버플로가 나기 쉽다. 때문에 `자동으로 힙에 메모리를 할당하는 STL 컨테이너를 사용하거나 전역 변수를 사용`하곤 한다.

### 다차원 배열 인덱스 순서 바꿔 쓰기

평소에는 2 차원 이상의 다차원 배열을 사용할 일이 많지만, 프로그래밍대회에서는 5 차원 이상의고차원 배열을 쓰게 된다. 이 배열을 이곳 저곳에서 접근하면 한군데 즘에서 인덱스으 ㅣ순서를 헷갈려서 잘못 쓰는 경우가 발생하는 일이 흔하다. 동적 계획법을 위한 메모이제이션 패턴을 사용할 떄 이런 일이 잦은데 이런 경우에는 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다.

### 잘못된 비교 함수 작성

### 최소 최대 예외 잘못 다루기

### 연산자 우선순위 잘못 쓰기

### 변수 초기화 문제

## 3.4 디버깅과 테스팅

### 디버깅에 대하여

### 테스트에 대하여

## 3.5 변수 범위의 이해

### 산술 오버플로

### 너무 큰 결과

### 너무 큰 중간 값

### 너무 큰 '무한대' 값

### 오버플로 피해가기

### 자료형의 프로모션

## 3.6 실수 자료형의 이해

### 실수 연산의 어려움

### 실수와 근사 값

### IEEE 754 표준

### 실수의 이진법 표기

### 부동 소수점 표기

### 실수 비교하기

1. 비교할 실수의 크기들에 비례한 오차 한도를 정한다.
2. 상대 오차를 이용한다.

### 대소비교

### 정확한 사칙연산

### 코드의 수치적 안정성 파악하기

### 경고

### 실수 연산 아예 하지 않기

## 느낀 점

디버깅에 대한 종류는 너무 많다! 조금 나중에 다시 읽어보도록 하자 - 18.09
