어떤 작어빙 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법을 가리켜 알고리즘이라고 한다. `같은 일을 하지만 여러가지의 방법이 있다. 이처럼 주어진 문제를 해결하는 한가지 방법을 명료하게 써 놓은 것을 알고리즘이라고 한다. 주관적이거나 모호한 것은 알고리즘이라고 할 수 없다.` 특히 컴퓨터과학에서 알고리즘이란 컴퓨터가 따라 할 수 있도록 자세히 설명한 과정을 나타내기 때문에 후자와 같은 것은 알고리즘이라고 할 수 없다.

가능한 한 명료하고 모호하지 않은 표현을 위해 사람들은 알고리즘을 대개 의사코드나 그것을 구현한 소스 코드의 형태로 설명한다. 때문에 처음에는 소스코드와 알고리즘이 같은 것이라고 여기기 쉽다. 그러나 알고리즘은 문제를 해결하는 방법 그 자체를 가리키기 때문에, 완전히 달라보이거나 다른 언어로 쓰인 프로그램이라고 해도 같은 원리에 따라 동작한다면 같은 알고리즘을 사용한다고 할 수 있다.

알고리즘을 평가하는 두 가지의 큰 기준은 알고리즘이 사용하는 시간과 공간이다.

- 시간 : 알고리즘이 적은 시간을 사용한다는 것은 더 빠르게 동작한다는 이야기다. 알고리즘의 수행 속도와 특성을 분석하는 능력을 키울 필요가 있다.
- 공간 : 알고리즘이 적은 공간을 사용한다는 것은 더 적은 용량의 메모리를 사용한다는 이야기다. 알고리즘이 이론적으로 아무리 빠르더라도 너무 많은 메모리 공간을 요구한다면 수행할 수 없을 것이다.

두 기준은 서로 상충하는 경우가 ㅁ낳다. 물론 더 빠르면서 메모리도 더 적게 사용하는 알고리즘이 있을 수는 있지만, 메모리 사용량을 희생해 속도를 높이거나, 속도를 희생해서 메모리 사용량을 줄인 알고리즘들을 훨씬 자주 볼 수 있다. 8 장에서 다루는 동적 계획법의 경우 더 많은 메모리를 사용해 알고리즘의 수행 속도를 높이는 대표적인 예이다. 프로그래밍 대회에서 주로 중요시 되는 알고리즘의기준은 속도이다. 지금부터 알고리즘의 속도를 분석하는 방법과 알고리즘의 정당성을 증명하는 기술들을 소개해보자.

# 알고리즘의 시간 복잡도 분석

## 4.1 도입

좀 더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일은 바로 알고리즘의 속도를 어떻게 측정할지를 정하는 것이다. 알고리즘의 속도를 측정할 수 없다면 개선했을 때 빨라졌는지 느려졌는지 측정할 수 없기 때문이다.

두 알고리즘의 속도를 비교하는 가장 직관적인 방법은 수행시간을 측정하는 것이다. 이 기준은 현실적으로도 유용하다. 이론적으로 아무리 빨라도 실제적으로 사용자가 느끼기에 느리다면 아무 소용이 없기 떄문이다. `하지만 프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 부적합하다. 가장 큰 이유는 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어는 물론이고 운영체제, 컴파일러 까지 수많은 요소에 의해 바뀔수 있기 때문이다.` 더 빠르게 동작하던 코드가 다른 컴퓨터에서는 더 느리게 동작하는 일은 얼마든지 있을 수 있는 일이다. 심지어 이런 외적 요인을 전부 통일하더라도 어떤 문자열 구현을 사용했는지, 함수 인자를 어떻게 넘겼는지 등의 사소한 문제에 따라 프로그램의 최종 수행 시간은 크게 달라질 수 있다. `두번째 이유는 실제 수행 시간이 다양한 입려겡 대한 실행 시간을 반영하지 못한다는 것이다. 알고리즘은 언제나 같은 속도로 동작하는 것이 아니며, 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있다.` 그렇다면 수행시간을 어떤 기준으로 측정해야 하는가?

### 반복문이 지배한다.

`한 가지 항목이 전체의 대소를 좌지우지하는 것을 지배한다라고 표현을 한다.`

알고리즘의 수행 시간을 지배하는 것은 바로 반복문이다. 물론 입력에 상관없이 항상 같은 수행 시간을 갖는 알고리즘도 있지만 대개는 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이다. `입력의 크기가 작으면 반복외의 다른 부분들이 비중이 클 수 있지만, 입력의 크기가 커지면 커질수록 반복문이 알고리즘의 수행 시간이 지배하게 된다.`따라서 우리는 대개 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다. 이때 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현된다.

주어진 배열에서 가장 많이 등장하는 수를 찾는 아래 코드를 살펴ㅗㅂ자
이 알고리즘의 수행 시간은 배열의 크기 N 에 따라 변한다. N 번 수행되는 반복문이 2 개 겹쳐져 있으므로 반복문의 가장 안쪽은 항상 N**2 번 실행된다. 따라서 알고리즘의 수행시간은 N**2 이다.

```C++
int majority1(const vector<int>&A){
  int N = A.size();
  int maijority = -1, majorityCount = 0;
  for(int i = 0; i< N; ++i>){
    int V = A[i], count =0;
    for(int j=0; j<N; ++j){
      if(A[j]==V){
        ++count;
      }
    }
    if(count>majorityCount){
      majorityCount = count;
      majority = V;
    }
  }
  return majority;
}
```

입력으로 주어지는 숫자들이 사실 100 점 만점으로 주어지는 중간 고사 점수라고 하면 이처럼 숫자의 범위가 작다면 배열을 이용해 각 숫자가 등장하는 횟수를 쉽게 셀 수 있다. 그리고 마지막에 빈도수 배열을 순회하면서 최대치의 위치를 찾으면 된다. 다음은 이것을 구현한 코드이다.

```C++
int majority2(const vector<int>& A){
  int N = A.size();
  vector<int> count(101,0);
  for(int i=0; i<N; ++i){
    count[A[i]]++;
  }
  // 지금까지 확인한 숫자 중 빈도수가 제일 큰 것을 majority에 저장한다.
  int majority = 0;
  for(int i=0; i<=100; ++i){
    if(count[i]> count[majority]){
      majority = i;
    }
  }
  return majority;
}
```

알고리즘의 수행 시간은 ㅐㅁ우 종류가 다양하지만 크게 몇가지 분류로 나눌 수 있다. 대표적인 몇가지 수행 시간의 형태를 살펴보면서 알고리즘 효율성 분석의 예제를 보도록 하자

## 4.2 선형 시간 알고리즘

### 다이어트 현황 파악 : 이동 평균 계산하기

이동평균은 주식의 가격, 연간 국내 총생산, 여자친구의 몸무게 등 시간에 따라 변화하는 값들을 관찰할 대 유용하게 사용할 수 있는 통계적 기준이다. 시간에 따라 관찰된 숫자들이 주어질 때 M-이동 평균은 마지막 M 개의 관찰 값의 평균으로 정의된다. 따라서 새 관찰 값이 나오면 M-이동 평균은 새 관찰 값을 포함하도록 바뀐다.
